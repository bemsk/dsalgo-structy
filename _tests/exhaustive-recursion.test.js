const subsets = require('../exhaustive-recursion/subset')
const permutations = require('../exhaustive-recursion/permutations')
const createCombinations = require('../exhaustive-recursion/create-combinations')
const parentheticalPossibilities = require('../exhaustive-recursion/parenthetical-possibilities')
const substitutingSynonyms = require('../exhaustive-recursion/substituting-synonyms')

describe('subsets', () => {
    test('should return a 2D array where each subarray represents one of the possible subsets of the array', () => {

        expect(subsets(['a', 'b'])).toStrictEqual([
            [],
            [ 'b' ],
            [ 'a' ],
            [ 'a', 'b' ]
        ])

        expect(subsets(['a', 'b', 'c'])).toStrictEqual([
            [],
            [ 'c' ],
            [ 'b' ],
            [ 'b', 'c' ],
            [ 'a' ],
            [ 'a', 'c' ],
            [ 'a', 'b' ],
            [ 'a', 'b', 'c' ]
        ])

        expect(subsets(['x'])).toStrictEqual([
            [],
            [ 'x' ]
        ])

        expect(subsets([])).toStrictEqual([
            []
        ])

        expect(subsets(['q', 'r', 's', 't'])).toStrictEqual([
            [],
            [ 't' ],
            [ 's' ],
            [ 's', 't' ],
            [ 'r' ],
            [ 'r', 't' ],
            [ 'r', 's' ],
            [ 'r', 's', 't' ],
            [ 'q' ],
            [ 'q', 't' ],
            [ 'q', 's' ],
            [ 'q', 's', 't' ],
            [ 'q', 'r' ],
            [ 'q', 'r', 't' ],
            [ 'q', 'r', 's' ],
            [ 'q', 'r', 's', 't' ]
        ])
    })
})

describe('permutations', () => {
    test('should return a 2D array where each subarray represents one of the possible permutations of the array', () => {
        expect(permutations(['a', 'b', 'c'])).toStrictEqual([
            [ 'a', 'b', 'c' ],
            [ 'b', 'a', 'c' ],
            [ 'b', 'c', 'a' ],
            [ 'a', 'c', 'b' ],
            [ 'c', 'a', 'b' ],
            [ 'c', 'b', 'a' ]
        ])
        expect(permutations(['red', 'blue'])).toStrictEqual([
            [ 'red', 'blue' ],
            [ 'blue', 'red' ]
        ])
        expect([8, 2, 1, 4]).toStrictEqual(expect.arrayContaining(
            [ 8, 2, 1, 4 ], [ 2, 8, 1, 4 ],
            [ 2, 1, 8, 4 ], [ 2, 1, 4, 8 ],
            [ 8, 1, 2, 4 ], [ 1, 8, 2, 4 ],
            [ 1, 2, 8, 4 ], [ 1, 2, 4, 8 ],
            [ 8, 1, 4, 2 ], [ 1, 8, 4, 2 ],
            [ 1, 4, 8, 2 ], [ 1, 4, 2, 8 ],
            [ 8, 2, 4, 1 ], [ 2, 8, 4, 1 ],
            [ 2, 4, 8, 1 ], [ 2, 4, 1, 8 ],
            [ 8, 4, 2, 1 ], [ 4, 8, 2, 1 ],
            [ 4, 2, 8, 1 ], [ 4, 2, 1, 8 ],
            [ 8, 4, 1, 2 ], [ 4, 8, 1, 2 ],
            [ 4, 1, 8, 2 ], [ 4, 1, 2, 8 ]
        ))
        expect([]).toStrictEqual(expect.arrayContaining([]))
    })
})

describe('create combinations', () => {
    test('should return a 2D array representing all of the combinations of the specifized length', () => {
        expect(createCombinations(["a", "b", "c"], 2)).toStrictEqual(expect.arrayContaining([
            [ 'a', 'b' ],
            [ 'a', 'c' ],
            [ 'b', 'c' ]
        ]))
        expect(createCombinations(["q", "r", "s", "t"], 2)).toStrictEqual(expect.arrayContaining([
            [ 'q', 'r' ],
            [ 'q', 's' ],
            [ 'q', 't' ],
            [ 'r', 's' ],
            [ 'r', 't' ],
            [ 's', 't' ]
        ]))
        expect(createCombinations(['q', 'r', 's', 't'], 3)).toStrictEqual(expect.arrayContaining([
            [ 'q', 'r', 's' ],
            [ 'q', 'r', 't' ],
            [ 'q', 's', 't' ],
            [ 'r', 's', 't' ]
        ]))
        expect(createCombinations([1, 28, 94], 3)).toStrictEqual(expect.arrayContaining([
            [ 1, 28, 94 ]
        ]))
    })
})

describe('parenthetical possibilities', () => {
    test('should return an array containing all of the strings that could be generated by expanding all parentheses of the string into its possibilities', () => {
        expect(parentheticalPossibilities("x(mn)yz")).toEqual(expect.arrayContaining([ 'xmyz', 'xnyz' ]))
        expect(parentheticalPossibilities("(qr)ab(stu)c")).toEqual(expect.arrayContaining([ 'qabsc', 'qabtc', 'qabuc', 'rabsc', 'rabtc', 'rabuc' ]))
        expect(parentheticalPossibilities("taco")).toEqual(expect.arrayContaining(['taco']))
        expect(parentheticalPossibilities("")).toEqual(expect.arrayContaining(['']))
        expect(parentheticalPossibilities("(etc)(blvd)(cat)")).toEqual(expect.arrayContaining([
            'ebc', 'eba', 'ebt', 'elc', 'ela',
            'elt', 'evc', 'eva', 'evt', 'edc',
            'eda', 'edt', 'tbc', 'tba', 'tbt',
            'tlc', 'tla', 'tlt', 'tvc', 'tva',
            'tvt', 'tdc', 'tda', 'tdt', 'cbc',
            'cba', 'cbt', 'clc', 'cla', 'clt',
            'cvc', 'cva', 'cvt', 'cdc', 'cda',
            'cdt'
        ]))
    })
})

describe('substituting synonyms', () => {
    test('should return an array containing all possible sentences that can be formed by substituting words of the sentence with their synonyms', () => {
        const sentence = "follow the yellow brick road";
        const synonyms = {
            follow: ["chase", "pursue"],
            yellow: ["gold", "amber", "lemon"],
        }

        expect(substitutingSynonyms(sentence, synonyms)).toEqual(expect.arrayContaining([
            'chase the gold brick road',
            'chase the amber brick road',
            'chase the lemon brick road',
            'pursue the gold brick road',
            'pursue the amber brick road',
            'pursue the lemon brick road'
        ]))
    })
})